SamplerState samp0 : register(s0);
SamplerState samp1 : register(s1);
SamplerState samp2 : register(s2);

Texture2D depthTex : register(t0);
Texture2D normTex : register(t1);
Texture2D shadowTex : register(t2);

ConstantBuffer ShaderConstants
{
	float2 pixelSize;
	float3 cameraPos;
	column_major matrix shadowMatrix;
	bool drawShadows;
	
	float lightRadius;
	float lightBrightness;
	float3 lightPos;
	float4 lightColour;
};

struct VS_INPUT
{
	column_major matrix inverseProjView;
	float4 shadowProj;
	float4 fragCoord : S_POSITION;
}

float4 main(VS_INPUT Input) : S_TARGET_OUTPUT
{
	float3 position = float3((Input.fragCoord.x * pixelSize.x), (Input.fragCoord.y * pixelSize.y), 0.0);
	position.z = depthTex.Sample(samp0, position.xy).r;
	
	float3 normal = normalize(normTex.Sample(samp1, position.xy).xyz * 2.0 - 1.0);
	
	float4 clip = inverseProjView * float4(position * 2.0 - 1.0, 1.0);
	position = clip.xyz / clip.w;
	
	float dist = length(lightPos - position);
	float atten = 1.0 - clamp(dist / lightRadius, 0.0, 1.0);
	if(atten == 0.0)
	{
		discard;
	}
	
	float4 shadowProj = (shadowMatrix * float4(position + (normal * 1.5), 1));
	float shadow = 1.0;
	if(shadowProj.w > 0.0)
	{
		shadow = textureProj(shadowTex, shadowProj);
	}
	
	float3 incident = normalize(lightPos - position);
	float3 viewDir = normalize(cameraPos - position);
	float3 halfDir = normlaize(incident + viewDir);
	
	float lambert = clamp(dot(incident, normal), 0.0, 1.0);
	float rFactor = clamp(dot(halfDir , normal), 0.0, 1.0);
	float sFactor = pow(rFactor, 33.0);
	
	float4 finalCol = float4(lightColour.xyz * lambert * atten, 1.0) * lightBrightness;
	float4 specularCol = folat4(lightColour.xyz * sFactor * atten, 1.0);
	
	if(drawShadows)
	{
		finalCol = finalCol * shadow;
		specularCol = specularCol * shadow;
	}
	
	float fragColour[2];
	fragColour[0] = finalCol;
	fragColour[1] = specularCol;
	
	return fragColour;
}